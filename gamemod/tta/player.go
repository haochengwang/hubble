package main

import (
	"fmt"
	"sort"
)

const (
	MILI_INFANTRY int = iota
	MILI_CAVALRY
	MILI_ARTILERY
	MILI_AIRFORCE
	FARM
	MINE
	URBAN_TEMPLE
	URBAN_LAB
	URBAN_ARENA
	URBAN_LIBRARY
	URBAN_THEATER
	GOVERNMENT
	LEADER
	WONDER_NOT_COMPLETED
	WONDER_COMPLETED
	TECH_SPECIAL_CIVIL
	TECH_SPECIAL_WARFARE
	TECH_SPECIAL_COLONIZE
	TECH_SPECIAL_CONSTRUCTION
	TACTIC
	PACT
	WAR
	PENDING
	HAND
	MILI_HAND
	USER_STACK_SIZE
)

const (
	PLAYER_0 = iota
	PLAYER_1
	PLAYER_2
	PLAYER_3
	PACT_A
	PACT_B
	FREE_YELLOW
	FREE_BLUE
	FREE_WORKER
	WHITE_USED
	WHITE_UNUSED
	WHITE_TEMP
	RED_USED
	RED_UNUSED
	// Temporal red token this turn, used ONLY WHEN BUILDING army
	// Generated by patriotism.
	RED_TEMP
	// Temporal resource this turn, used ONLY WHEN BUILDING or UPGRADING army
	// Generated by Churchill
	MILITARY_RESOURCE_TEMP
	// Temporal tech this turn, used ONLY WHEN DEVELOPING military (red)
	// techs.
	// Generated by Churchill.
	MILITARY_TECH_TEMP
	// Temporal resource this turn, used ONLY WHEN BUILDING or UPGRADING army
	// Generated by patriotism, military build-up and wave of
	// nationalism.
	MILITARY_RESOURCE_TEMP_BUILD_ONLY

	CULTURE_COUNTER
	TECH_COUNTER
	LEADER_A_TAKEN
	LEADER_I_TAKEN
	LEADER_II_TAKEN
	LEADER_III_TAKEN
	PER_TURN_SKILLS_COUNTER
	PER_GAME_SKILLS_COUNTER
)

const (
	TOKEN_DEFAULT = iota
	TOKEN_YELLOW
	TOKEN_BLUE
	TOKEN_WHITE
	TOKEN_RED
	TOKEN_ACTION_CARD_THIS_TURN
)

type PlayerBoard struct {
	game *TtaGame

	stacks              []int
	techTokenManager    *TokenBankUniversalManager
	specialTokenManager *TokenBankUniversalManager
	perTurnTokenManager *TokenBankUniversalManager
}

func initPlayerBoard(game *TtaGame) (result *PlayerBoard) {
	csm := game.cardStackManager
	stacks := make([]int, USER_STACK_SIZE)

	// Prepare stacks
	for i := 0; i < USER_STACK_SIZE; i++ {
		stacks[i] = csm.newStack()
	}

	// Prepare initial cards
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[MILI_INFANTRY],
			position: 0,
		},
		schoolId: 25,
	})
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[FARM],
			position: 0,
		},
		schoolId: 1,
	})
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[MINE],
			position: 0,
		},
		schoolId: 5,
	})
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[URBAN_TEMPLE],
			position: 0,
		},
		schoolId: 13,
	})
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[URBAN_LAB],
			position: 0,
		},
		schoolId: 9,
	})
	csm.processRequest(&AddCardRequest{
		position: CardPosition{
			stackId:  stacks[GOVERNMENT],
			position: 0,
		},
		schoolId: 35,
	})
	// Prepare initial tokens for agriculture and bronze
	agricultureCard := csm.getFirstCard(stacks[FARM])
	bronzeCard := csm.getFirstCard(stacks[MINE])

	warriorCard := csm.getFirstCard(stacks[MILI_INFANTRY])
	governmentCard := csm.getFirstCard(stacks[GOVERNMENT])

	labCard := csm.getFirstCard(stacks[URBAN_LAB])

	game.cardTokenManager.setTokenCount(agricultureCard.id, TOKEN_YELLOW, 2)
	game.cardTokenManager.setTokenCount(bronzeCard.id, TOKEN_YELLOW, 2)
	game.cardTokenManager.setTokenCount(warriorCard.id, TOKEN_YELLOW, 1)
	game.cardTokenManager.setTokenCount(governmentCard.id, TOKEN_WHITE, 4)
	game.cardTokenManager.setTokenCount(governmentCard.id, TOKEN_RED, 2)

	game.cardTokenManager.setTokenCount(labCard.id, TOKEN_YELLOW, 1)

	// Prepare special bank manager
	specialTokenManager := NewTokenBankUniversalManager()
	specialTokenManager.setTokenCount(FREE_WORKER, TOKEN_YELLOW, 1)
	specialTokenManager.setTokenCount(FREE_YELLOW, TOKEN_YELLOW, 18)
	specialTokenManager.setTokenCount(FREE_BLUE, TOKEN_BLUE, 16)

	// Prepare tech bank Manager
	techTokenManager := NewTokenBankUniversalManager()
	perTurnTokenManager := NewTokenBankUniversalManager()

	// Finish
	return &PlayerBoard{
		game:                game,
		stacks:              stacks,
		specialTokenManager: specialTokenManager,
		techTokenManager:    techTokenManager,
		perTurnTokenManager: perTurnTokenManager,
	}
}

func (p *PlayerBoard) getIndex() int {
	for i, pp := range p.game.players {
		if p == pp {
			return i
		}
	}
	return -1
}

func (p *PlayerBoard) getCultureTotal() int {
	return p.specialTokenManager.getTokenCount(CULTURE_COUNTER, TOKEN_DEFAULT)
}

func (p *PlayerBoard) getTechTotal() int {
	return p.specialTokenManager.getTokenCount(TECH_COUNTER, TOKEN_DEFAULT)
}

func (p *PlayerBoard) getTechForMilitary() int {
	return p.specialTokenManager.getTokenCount(MILITARY_TECH_TEMP, TOKEN_DEFAULT)

}

func (p *PlayerBoard) getUsableWhiteTokens() int {
	return p.specialTokenManager.getTokenCount(WHITE_UNUSED, TOKEN_WHITE) +
		p.specialTokenManager.getTokenCount(WHITE_TEMP, TOKEN_WHITE)
}

func (p *PlayerBoard) getTempWhiteTokens() int {
	return p.specialTokenManager.getTokenCount(WHITE_TEMP, TOKEN_WHITE)
}

func (p *PlayerBoard) getUsedWhiteTokens() int {
	return p.specialTokenManager.getTokenCount(WHITE_USED, TOKEN_WHITE)
}

func (p *PlayerBoard) getUsableRedTokens() int {
	return p.specialTokenManager.getTokenCount(RED_UNUSED, TOKEN_RED)
}

func (p *PlayerBoard) getUsableRedTokensForBuildArmy() int {
	return p.specialTokenManager.getTokenCount(RED_UNUSED, TOKEN_RED) +
		p.specialTokenManager.getTokenCount(RED_TEMP, TOKEN_RED)
}

func (p *PlayerBoard) getTempRedTokens() int {
	return p.specialTokenManager.getTokenCount(RED_TEMP, TOKEN_RED)
}

func (p *PlayerBoard) getUsedRedTokens() int {
	return p.specialTokenManager.getTokenCount(RED_USED, TOKEN_RED)
}

func (p *PlayerBoard) getFreeWorkers() int {
	return p.specialTokenManager.getTokenCount(FREE_WORKER, TOKEN_YELLOW)
}

func (p *PlayerBoard) getFreeYellowTokens() int {
	return p.specialTokenManager.getTokenCount(FREE_YELLOW, TOKEN_YELLOW)
}

func (p *PlayerBoard) getFreeBlueTokens() int {
	return p.specialTokenManager.getTokenCount(FREE_BLUE, TOKEN_BLUE)
}

func (p *PlayerBoard) getBlueTokensOnMine() int {
	csm := p.game.cardStackManager
	result := 0
	for _, card := range csm.cardStacks[p.stacks[MINE]] {
		result += p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
	}
	return result
}

func (p *PlayerBoard) getConstructionTechLevel() int {
	csm := p.game.cardStackManager
	card := csm.getFirstCard(p.stacks[TECH_SPECIAL_CONSTRUCTION])
	if card == nil {
		return 0
	}
	school := p.game.cardSchools[card.schoolId]
	return school.age
}

func (p *PlayerBoard) getCivilHandSize() int {
	csm := p.game.cardStackManager
	return csm.getStackSize(p.stacks[HAND])
}

func (p *PlayerBoard) getMaxCivilHandSize() int {
	handSize := p.calcWhiteTokenLimit()
	if p.specialAbilityAvailable(TRAIT_LIB_OF_ALEXANDRIA) {
		handSize += 1
	}
	return handSize
}

func (p *PlayerBoard) getMilitaryHandSize() int {
	csm := p.game.cardStackManager
	return csm.getStackSize(p.stacks[MILI_HAND])
}

func (p *PlayerBoard) getMaxMilitaryHandSize() int {
	handSize := p.calcRedTokenLimit()
	if p.specialAbilityAvailable(TRAIT_LIB_OF_ALEXANDRIA) {
		handSize += 1
	}
	return handSize
}

func (p *PlayerBoard) getUrbanCount(stack int) int {
	csm := p.game.cardStackManager
	result := 0
	for _, card := range csm.cardStacks[p.stacks[stack]] {
		result += p.game.cardTokenManager.getTokenCount(card.id, TOKEN_YELLOW)
	}
	return result
}

func (p *PlayerBoard) getWorkerCount(stack int, index int) int {
	csm := p.game.cardStackManager
	if index < 0 || index >= csm.getStackSize(p.stacks[stack]) {
		return 0
	}
	card := csm.cardStacks[p.stacks[stack]][index]
	return p.game.cardTokenManager.getTokenCount(card.id, TOKEN_YELLOW)
}

func (p *PlayerBoard) getCardSchool(stack int, index int) *CardSchool {
	csm := p.game.cardStackManager
	if index < 0 || index >= csm.getStackSize(p.stacks[stack]) {
		return nil
	}
	card := csm.cardStacks[p.stacks[stack]][index]
	return p.game.cardSchools[card.schoolId]
}

func (p *PlayerBoard) getTempMilitaryResource() int {
	return p.specialTokenManager.getTokenCount(MILITARY_RESOURCE_TEMP, TOKEN_BLUE)
}

func (p *PlayerBoard) getTempMilitaryResourceForBuildArmy() int {
	return p.specialTokenManager.getTokenCount(MILITARY_RESOURCE_TEMP_BUILD_ONLY,
		TOKEN_BLUE)
}

func (p *PlayerBoard) perTurnSpecialAbilityUsed(sa int) bool {
	return p.perTurnTokenManager.getTokenCount(sa, TOKEN_DEFAULT) > 0
}

func (p *PlayerBoard) setUsableWhiteTokens(white int) {
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     WHITE_UNUSED,
		tokenType:  TOKEN_WHITE,
		tokenCount: white,
	})
}

func (p *PlayerBoard) markPerTurnSpecialAbility(sa int) {
	p.perTurnTokenManager.processRequest(&SetTokenRequest{
		bankId:     sa,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: 1,
	})
}

func (p *PlayerBoard) removeFreeWorkers(amount int) {
	p.specialTokenManager.processRequest(&MoveTokenRequest{
		sourceBankId: FREE_WORKER,
		targetBankId: FREE_YELLOW,
		tokenType:    TOKEN_YELLOW,
		tokenCount:   amount,
	})
}

func (p *PlayerBoard) clearPerTurnSpecialAbility() {
	p.perTurnTokenManager.processRequest(&ClearAllTokensRequest{})
}

func (p *PlayerBoard) getResourceCorruption() int {
	freeBlue := p.getFreeBlueTokens()
	switch freeBlue {
	case 0:
		return 6
	case 1, 2, 3, 4, 5:
		return 4
	case 6, 7, 8, 9, 10:
		return 2
	default:
		return 0
	}
}

func (p *PlayerBoard) getCropConsume() int {
	freeYellow := p.getFreeYellowTokens()
	switch freeYellow {
	case 0:
		return 6
	case 1, 2, 3, 4:
		return 4
	case 5, 6, 7, 8:
		return 3
	case 9, 10, 11, 12:
		return 2
	case 13, 14, 15, 16:
		return 1
	default:
		return 0
	}
}

func (p *PlayerBoard) getIncreasePopBaseCost() int {
	freeYellow := p.getFreeYellowTokens()
	switch freeYellow {
	case 0:
		return -1
	case 1, 2, 3, 4:
		return 7
	case 5, 6, 7, 8:
		return 5
	case 9, 10, 11, 12:
		return 4
	case 13, 14, 15, 16:
		return 3
	default:
		return 2
	}
}

func (p *PlayerBoard) getNeededHappiness() int {
	freeYellow := p.getFreeYellowTokens()
	switch freeYellow {
	case 0:
		return 8
	case 1, 2:
		return 7
	case 3, 4:
		return 6
	case 5, 6:
		return 5
	case 7, 8:
		return 4
	case 9, 10:
		return 3
	case 11, 12:
		return 2
	case 13, 14, 15, 16:
		return 1
	default:
		return 0
	}
}

func (p *PlayerBoard) gainTempWhiteTokens(amount int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     WHITE_TEMP,
		tokenType:  TOKEN_WHITE,
		tokenCount: amount,
	})

}

func (p *PlayerBoard) gainTempRedTokens(amount int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     RED_TEMP,
		tokenType:  TOKEN_RED,
		tokenCount: amount,
	})
}

func (p *PlayerBoard) removeUsableWhiteTokens(count int) {
	if count < p.getTempWhiteTokens() {
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     WHITE_TEMP,
			tokenType:  TOKEN_WHITE,
			tokenCount: count,
		})
	} else {
		temp := p.getTempWhiteTokens()
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     WHITE_TEMP,
			tokenType:  TOKEN_WHITE,
			tokenCount: temp,
		})
		p.specialTokenManager.processRequest(&MoveTokenRequest{
			sourceBankId: WHITE_UNUSED,
			targetBankId: WHITE_USED,
			tokenType:    TOKEN_WHITE,
			tokenCount:   count - temp,
		})
	}
}

func (p *PlayerBoard) removeAllUsableWhiteTokens() {
	p.removeUsableWhiteTokens(p.getUsableWhiteTokens())
}

func (p *PlayerBoard) removeUsableRedTokens(count int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     RED_UNUSED,
		tokenType:  TOKEN_RED,
		tokenCount: count,
	})
}

func (p *PlayerBoard) removeUsableRedTokensForBuildArmy(count int) {
	if count < p.getTempRedTokens() {
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     RED_TEMP,
			tokenType:  TOKEN_RED,
			tokenCount: count,
		})
	} else {
		temp := p.getTempRedTokens()
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     RED_TEMP,
			tokenType:  TOKEN_RED,
			tokenCount: temp,
		})
		p.specialTokenManager.processRequest(&MoveTokenRequest{
			sourceBankId: RED_UNUSED,
			targetBankId: RED_USED,
			tokenType:    TOKEN_RED,
			tokenCount:   count - temp,
		})
	}
}

func (p *PlayerBoard) removeAllUsableRedTokens() {
	p.removeUsableRedTokens(p.getUsableRedTokens())
}

func (p *PlayerBoard) refillWhiteRedTokens() {
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     WHITE_UNUSED,
		tokenType:  TOKEN_WHITE,
		tokenCount: p.calcWhiteTokenLimit(),
	})
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     RED_UNUSED,
		tokenType:  TOKEN_RED,
		tokenCount: p.calcRedTokenLimit(),
	})
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     WHITE_USED,
		tokenType:  TOKEN_WHITE,
		tokenCount: 0,
	})
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     RED_USED,
		tokenType:  TOKEN_RED,
		tokenCount: 0,
	})
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     WHITE_TEMP,
		tokenType:  TOKEN_WHITE,
		tokenCount: 0,
	})
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     RED_USED,
		tokenType:  TOKEN_RED,
		tokenCount: 0,
	})
}

// Usually called after government or civil tech changed
func (p *PlayerBoard) realignWhiteRedTokens() {
	whiteLimit := p.calcWhiteTokenLimit()
	redLimit := p.calcRedTokenLimit()
	whiteSum := p.getUsableWhiteTokens() + p.getUsedWhiteTokens()
	redSum := p.getUsableRedTokens() + p.getUsedRedTokens()

	if whiteLimit != whiteSum {
		if whiteLimit > whiteSum {
			p.specialTokenManager.processRequest(&AddTokenRequest{
				bankId:     WHITE_UNUSED,
				tokenType:  TOKEN_WHITE,
				tokenCount: whiteLimit - whiteSum,
			})
		} else { // whiteLimit < whiteSum
			unused := p.getUsableWhiteTokens()
			diff := whiteSum - whiteLimit
			if unused >= diff {
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     WHITE_UNUSED,
					tokenType:  TOKEN_WHITE,
					tokenCount: diff,
				})
			} else {
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     WHITE_UNUSED,
					tokenType:  TOKEN_WHITE,
					tokenCount: unused,
				})
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     WHITE_USED,
					tokenType:  TOKEN_WHITE,
					tokenCount: diff - unused,
				})
			}
		}
	}

	if redLimit != redSum {
		if redLimit > redSum {
			p.specialTokenManager.processRequest(&AddTokenRequest{
				bankId:     RED_UNUSED,
				tokenType:  TOKEN_RED,
				tokenCount: redLimit - redSum,
			})
		} else { // redLimit < redSum
			unused := p.getUsableRedTokens()
			diff := redSum - redLimit
			if unused >= diff {
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     RED_UNUSED,
					tokenType:  TOKEN_RED,
					tokenCount: diff,
				})
			} else {
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     RED_UNUSED,
					tokenType:  TOKEN_RED,
					tokenCount: unused,
				})
				p.specialTokenManager.processRequest(&RemoveTokenRequest{
					bankId:     RED_USED,
					tokenType:  TOKEN_RED,
					tokenCount: diff - unused,
				})
			}
		}

	}
}

func (p *PlayerBoard) clearupTurn() {
	csm := p.game.cardStackManager
	p.realignWhiteRedTokens()
	for _, card := range csm.cardStacks[p.stacks[HAND]] {
		p.game.cardTokenManager.processRequest(&ClearTokenRequest{
			bankId:    card.id,
			tokenType: TOKEN_ACTION_CARD_THIS_TURN,
		})
	}
	p.specialTokenManager.processRequest(&ClearTokenRequest{
		bankId:    MILITARY_RESOURCE_TEMP,
		tokenType: TOKEN_BLUE,
	})
	p.specialTokenManager.processRequest(&ClearTokenRequest{
		bankId:    MILITARY_TECH_TEMP,
		tokenType: TOKEN_DEFAULT,
	})
	p.specialTokenManager.processRequest(&ClearTokenRequest{
		bankId:    MILITARY_RESOURCE_TEMP_BUILD_ONLY,
		tokenType: TOKEN_BLUE,
	})
	p.clearPerTurnSpecialAbility()
}

func (p *PlayerBoard) gainCulture(gain int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     CULTURE_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: gain,
	})
}

func (p *PlayerBoard) loseCulture(lose int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     CULTURE_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: lose,
	})
}

func (p *PlayerBoard) gainTech(gain int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     TECH_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: gain,
	})
}

func (p *PlayerBoard) loseTech(lose int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     TECH_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: lose,
	})
}

func (p *PlayerBoard) gainTempMilitaryTech(gain int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     MILITARY_TECH_TEMP,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: gain,
	})
}

func (p *PlayerBoard) payTech(pay int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     TECH_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: pay,
	})
}

func (p *PlayerBoard) payTechForMilitary(pay int) {
	a := p.getTechForMilitary()
	if a >= pay {
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     MILITARY_TECH_TEMP,
			tokenType:  TOKEN_DEFAULT,
			tokenCount: pay,
		})
	} else {
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     MILITARY_TECH_TEMP,
			tokenType:  TOKEN_DEFAULT,
			tokenCount: a,
		})
		p.payTech(pay - a)
	}
}

func (p *PlayerBoard) isBuildingWonder() bool {
	csm := p.game.cardStackManager
	return csm.getStackSize(p.stacks[WONDER_NOT_COMPLETED]) != 0
}

func (p *PlayerBoard) getBlueTokensOnCurrentWonder() int {
	csm := p.game.cardStackManager
	wonderCard := csm.getFirstCard(p.stacks[WONDER_NOT_COMPLETED])
	return p.game.cardTokenManager.getTokenCount(wonderCard.id, TOKEN_BLUE)
}

func (p *PlayerBoard) getCurrentHandSize() int {
	csm := p.game.cardStackManager
	return csm.getStackSize(p.stacks[HAND])
}

func (p *PlayerBoard) hasLeader() bool {
	csm := p.game.cardStackManager
	return csm.getStackSize(p.stacks[LEADER]) > 0
}

func (p *PlayerBoard) iterateOverTechs(f func(*CardSchool) int, canBeNegative bool) int {
	csm := p.game.cardStackManager
	allSchools := p.game.cardSchools
	result := 0
	// Government
	governmentCard := csm.getFirstCard(p.stacks[GOVERNMENT])
	result += f(allSchools[governmentCard.schoolId])

	// Army, Farms, mines and urban buildings counts yellow tokens
	for _, t := range []int{MILI_INFANTRY,
		MILI_CAVALRY,
		MILI_ARTILERY,
		MILI_AIRFORCE,
		FARM,
		MINE,
		URBAN_TEMPLE,
		URBAN_LAB,
		URBAN_ARENA,
		URBAN_LIBRARY,
		URBAN_THEATER,
	} {
		for _, card := range csm.cardStacks[p.stacks[t]] {
			result += f(allSchools[card.schoolId])
		}
	}

	// Special technology
	for _, t := range []int{
		TECH_SPECIAL_CIVIL,
		TECH_SPECIAL_WARFARE,
		TECH_SPECIAL_COLONIZE,
		TECH_SPECIAL_CONSTRUCTION,
	} {
		specialTechCard := csm.getFirstCard(p.stacks[t])
		if specialTechCard != nil {
			result += f(allSchools[specialTechCard.schoolId])
		}
	}

	if result < 0 && !canBeNegative {
		result = 0
	}
	return result
}

func (p *PlayerBoard) iterateOverUnitsAndEverything(
	f func(*CardSchool) interface{},
	reducer func(interface{}, interface{}) interface{}) interface{} {
	csm := p.game.cardStackManager
	allSchools := p.game.cardSchools
	var result interface{}
	// Government
	governmentCard := csm.getFirstCard(p.stacks[GOVERNMENT])
	result = f(allSchools[governmentCard.schoolId])

	// Army, Farms, mines and urban buildings counts yellow tokens
	for _, t := range []int{MILI_INFANTRY,
		MILI_CAVALRY,
		MILI_ARTILERY,
		MILI_AIRFORCE,
		FARM,
		MINE,
		URBAN_TEMPLE,
		URBAN_LAB,
		URBAN_ARENA,
		URBAN_LIBRARY,
		URBAN_THEATER,
	} {
		for _, card := range csm.cardStacks[p.stacks[t]] {
			for i := 0; i < p.game.cardTokenManager.getTokenCount(card.id, TOKEN_YELLOW); i++ {
				result = reducer(result, f(allSchools[card.schoolId]))
			}
		}
	}

	// Special technology
	for _, t := range []int{
		TECH_SPECIAL_CIVIL,
		TECH_SPECIAL_WARFARE,
		TECH_SPECIAL_COLONIZE,
		TECH_SPECIAL_CONSTRUCTION,
	} {
		specialTechCard := csm.getFirstCard(p.stacks[t])
		if specialTechCard != nil {
			result = reducer(result, f(allSchools[specialTechCard.schoolId]))
		}
	}

	// Leader
	for _, card := range csm.cardStacks[p.stacks[LEADER]] {
		result = reducer(result, f(allSchools[card.schoolId]))
	}
	// Wonders
	for _, card := range csm.cardStacks[p.stacks[WONDER_COMPLETED]] {
		result = reducer(result, f(allSchools[card.schoolId]))
	}
	// Pacts
	for _, card := range csm.cardStacks[p.stacks[PACT]] {
		school := allSchools[card.schoolId]
		if school.symmetric {
			result = reducer(result, f(school))
		} else {
			if p.game.cardTokenManager.getTokenCount(card.id, PACT_A) > 0 {
				result = reducer(result, f(school))
			} else if p.game.cardTokenManager.getTokenCount(card.id, PACT_B) > 0 {
				result = reducer(result, f(school.bSide))
			}
		}
	}

	// Pacts from other player
	for _, pp := range p.game.players {
		if p == pp {
			continue
		}
		for _, card := range csm.cardStacks[pp.stacks[PACT]] {
			if p.game.cardTokenManager.getTokenCount(card.id, p.getIndex()) > 0 {
				school := allSchools[card.schoolId]
				if school.symmetric {
					result = reducer(result, f(school))
				} else {
					if p.game.cardTokenManager.getTokenCount(card.id, PACT_B) > 0 {
						result = reducer(result, f(school))
					} else if p.game.cardTokenManager.getTokenCount(card.id, PACT_A) > 0 {
						result = reducer(result, f(school.bSide))
					}
				}

			}
		}
	}

	return result
}

func (p *PlayerBoard) sumOverUnitsAndEverything(
	f func(*CardSchool) interface{}, canBeNegative bool) int {
	result := p.iterateOverUnitsAndEverything(f,
		func(a interface{}, b interface{}) interface{} {
			return a.(int) + b.(int)
		}).(int)
	if !canBeNegative && result < 0 {
		return 0
	}
	return result
}

func (p *PlayerBoard) maxOverUnitsAndEverything(
	f func(*CardSchool) interface{}, canBeNegative bool) int {
	result := p.iterateOverUnitsAndEverything(f,
		func(a interface{}, b interface{}) interface{} {
			if a.(int) > b.(int) {
				return a.(int)
			} else {
				return b.(int)
			}
		}).(int)

	if !canBeNegative && result < 0 {
		return 0
	}
	return result
}

func (p *PlayerBoard) calcWhiteTokenLimit() int {
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		return school.productionWhiteToken
	}, false)
}

func (p *PlayerBoard) calcRedTokenLimit() int {
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		return school.productionRedToken
	}, false)
}

func (p *PlayerBoard) calcCultureInc() int {
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		if p.specialAbilityAvailable(TRAIT_CHARLIE_CHAPLIN) &&
			school.hasType(CARDTYPE_TECH_URBAN_THEATER) {
			return school.productionCulture * 2
		} else if p.specialAbilityAvailable(TRAIT_MICHELANGELO) &&
			(school.hasType(CARDTYPE_WONDER) ||
				school.hasType(CARDTYPE_TECH_URBAN_THEATER) ||
				school.hasType(CARDTYPE_TECH_URBAN_TEMPLE)) {
			return school.productionCulture + school.productionHappiness
		}
		return school.productionCulture
	}, false)
}

func (p *PlayerBoard) calcTechInc() int {
	tech := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		return school.productionTech
	}, false)

	if p.specialAbilityAvailable(TRAIT_LIB_LAB_AMPLIFY) {
		tech += p.maxOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_URBAN_LAB) ||
				school.hasType(CARDTYPE_TECH_URBAN_LIBRARY) {
				return school.age
			}
			return 0
		}, false)
	}

	return tech
}

func (p *PlayerBoard) getAvailableTactic() *CardSchool {
	csm := p.game.cardStackManager
	// TODO try to get public tactic area
	if csm.getStackSize(p.stacks[TACTIC]) > 0 {
		card := csm.cardStacks[p.stacks[TACTIC]][0]
		return p.game.cardSchools[card.schoolId]
	}

	pid := -1
	for i := 0; i < p.game.options.PlayerCount; i++ {
		if p == p.game.players[i] {
			pid = i
		}
	}
	for i := 0; i < csm.getStackSize(p.game.publicTacticDeck); i++ {
		card := csm.cardStacks[p.game.publicTacticDeck][i]
		if p.game.cardTokenManager.getTokenCount(card.id, pid) > 0 {
			fmt.Println("Current tactic school: ", card.schoolId)
			return p.game.cardSchools[card.schoolId]
		}
	}
	return nil
}

func (p *PlayerBoard) calcPowerFromTactic() int {
	tactic := p.getAvailableTactic()
	if tactic == nil {
		return 0
	}

	allTypes := p.iterateOverUnitsAndEverything(
		func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_MILI_INFANTRY) {
				if school.age > tactic.age-2 {
					return [][]int{[]int{1, 0, 0}, []int{1, 0, 0}}
				} else {
					return [][]int{[]int{0, 0, 0}, []int{1, 0, 0}}
				}
			} else if school.hasType(CARDTYPE_TECH_MILI_CAVALRY) {
				if school.age > tactic.age-2 {
					return [][]int{[]int{0, 1, 0}, []int{0, 1, 0}}
				} else {
					return [][]int{[]int{0, 0, 0}, []int{0, 1, 0}}
				}
			} else if school.hasType(CARDTYPE_TECH_MILI_ARTILLERY) {
				if school.age > tactic.age-2 {
					return [][]int{[]int{0, 0, 1}, []int{0, 0, 1}}
				} else {
					return [][]int{[]int{0, 0, 0}, []int{0, 0, 1}}
				}
			} else {
				return [][]int{[]int{0, 0, 0}, []int{0, 0, 0}}
			}
		},
		func(a interface{}, b interface{}) interface{} {
			type1 := a.([][]int)
			type2 := b.([][]int)
			result := [][]int{[]int{0, 0, 0}, []int{0, 0, 0}}
			for i := 0; i < len(result); i++ {
				for j := 0; j < len(result[0]); j++ {
					result[i][j] = type1[i][j] + type2[i][j]
				}
			}
			return result
		}).([][]int)
	requiredTypes := []int{0, 0, 0}
	for _, t := range tactic.formation {
		requiredTypes[t]++
	}

	allSet := 1 << 32 // Maxint
	for i := 0; i < 3; i++ {
		if requiredTypes[i] == 0 {
			continue
		}
		s := allTypes[1][i] / requiredTypes[i]
		if s < allSet {
			allSet = s
		}
	}
	upToDateSet := 1 << 32 // Maxint
	for i := 0; i < 3; i++ {
		if requiredTypes[i] == 0 {
			continue
		}
		s := allTypes[0][i] / requiredTypes[i]
		if s < allSet {
			upToDateSet = s
		}
	}
	return allSet*tactic.productionPowerLesser +
		upToDateSet*(tactic.productionPower-tactic.productionPowerLesser)
}

func (p *PlayerBoard) calcPower() int {
	power := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		ret := school.productionPower
		if p.specialAbilityAvailable(TRAIT_GREAT_WALL) &&
			(school.hasType(CARDTYPE_TECH_MILI_INFANTRY) ||
				school.hasType(CARDTYPE_TECH_MILI_ARTILLERY)) {
			ret += 1
		}

		if p.specialAbilityAvailable(TRAIT_ALEXANDER_THE_GREAT) &&
			(school.hasType(CARDTYPE_TECH_MILI_INFANTRY) ||
				school.hasType(CARDTYPE_TECH_MILI_CAVALRY) ||
				school.hasType(CARDTYPE_TECH_MILI_ARTILLERY) ||
				school.hasType(CARDTYPE_TECH_MILI_AIRFORCE)) {
			ret += 1
		}
		return ret
	}, false)

	fmt.Println("Strength from formation: ", p.calcPowerFromTactic())
	power += p.calcPowerFromTactic()

	if p.specialAbilityAvailable(TRAIT_JOAN_OF_ARC) {
		power += p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_GOVERNMENT) ||
				school.hasType(CARDTYPE_TECH_URBAN_TEMPLE) {
				return school.productionHappiness
			}
			return 0
		}, false)
	}

	if p.specialAbilityAvailable(TRAIT_NAPOLEON_BONAPARTE) {
		infantry := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_MILI_INFANTRY) {
				return 1
			} else {
				return 0
			}
		}, false)
		if infantry > 1 {
			infantry = 1
		}

		cavalry := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_MILI_CAVALRY) {
				return 1
			} else {
				return 0
			}
		}, false)
		if cavalry > 1 {
			cavalry = 1
		}

		artilery := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_MILI_ARTILLERY) {
				return 1
			} else {
				return 0
			}
		}, false)
		if artilery > 1 {
			artilery = 1
		}

		airforce := p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			if school.hasType(CARDTYPE_TECH_MILI_AIRFORCE) {
				return 1
			} else {
				return 0
			}
		}, false)
		if airforce > 1 {
			airforce = 1
		}

		power += infantry*2 + cavalry*2 + artilery*2 + airforce*2
	}
	return power
}

func (p *PlayerBoard) calcUrbanLimit() int {
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		return school.productionUrbanLimit
	}, false)
}

func (p *PlayerBoard) calcHappiness() int {
	if p.specialAbilityAvailable(TRAIT_ST_PETERS_BASILICA) {
		return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
			happiness := school.productionHappiness
			if happiness > 0 {
				return happiness + 1
			}
			return happiness
		}, false)
	}
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		return school.productionHappiness
	}, false)
}

func (p *PlayerBoard) specialAbilityAvailable(saId int) bool {
	return p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
		if school.hasTrait(saId) {
			return 1
		} else {
			return 0
		}
	}, false) > 0
}

func (p *PlayerBoard) canTakeCardFromWheel(index int) bool {
	card := p.game.getCardOnGreatWheel(index)
	// Assure card exists
	if card == nil {
		return false
	}

	// White tokens enough
	if p.getUsableWhiteTokens() < p.takeCardFromWheelCost(index) {
		return false
	}

	// Cannot take card if hand is full
	if p.getCurrentHandSize() >= p.calcWhiteTokenLimit() {
		return false
	}

	school := p.game.cardSchools[card.schoolId]
	// Cannot take wonder if another is under construction
	if school.hasType(CARDTYPE_WONDER) {
		if p.isBuildingWonder() {
			return false
		}
	}

	// Cannot take duplicate tech cards
	if school.hasType(CARDTYPE_TECH) {
		if p.techTokenManager.getTokenCount(card.schoolId, TOKEN_DEFAULT) > 0 {
			return false
		}
	}

	// Cannot take leader with duplicate ages
	if school.hasType(CARDTYPE_LEADER) {
		if p.specialTokenManager.getTokenCount(LEADER_A_TAKEN+school.age,
			TOKEN_DEFAULT) > 0 {
			return false
		}
	}
	return true
}

func (p *PlayerBoard) takeCardFromWheelCost(index int) (cost int) {
	csm := p.game.cardStackManager
	switch index {
	case 0, 1, 2, 3, 4:
		cost = 1
	case 5, 6, 7, 8:
		cost = 2
	case 9, 10, 11, 12:
		cost = 3
	default:
		return -1
	}

	card := csm.getFirstCard(p.game.greatWheel[index])
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_WONDER) {
		if !p.specialAbilityAvailable(TRAIT_MICHELANGELO) {
			cost += csm.getStackSize(p.stacks[WONDER_COMPLETED])
		}
	}

	if p.specialAbilityAvailable(TRAIT_HAMMURABI) && school.hasType(CARDTYPE_LEADER) {
		cost -= 1
	}

	if school.hasTrait(TRAIT_TAJ_MAHAL) {
		cost -= 2
	}
	if cost < 0 {
		cost = 0
	}
	return
}

func (p *PlayerBoard) takeCardFromWheel(index int) {
	csm := p.game.cardStackManager
	card := p.game.getCardOnGreatWheel(index)

	if card == nil {
		return
	}
	cost := p.takeCardFromWheelCost(index)
	if p.canTakeCardFromWheel(index) {
		// Move the card
		school := p.game.cardSchools[card.schoolId]
		if school.hasType(CARDTYPE_WONDER) {
			csm.processRequest(&MoveCardRequest{
				sourcePosition: CardPosition{
					stackId:  p.game.greatWheel[index],
					position: 0,
				},
				targetPosition: CardPosition{
					stackId:  p.stacks[WONDER_NOT_COMPLETED],
					position: 0,
				},
			})
		} else {
			csm.processRequest(&MoveCardRequest{
				sourcePosition: CardPosition{
					stackId:  p.game.greatWheel[index],
					position: 0,
				},
				targetPosition: CardPosition{
					stackId:  p.stacks[HAND],
					position: 0,
				},
			})
		}

		// Remove white tokens used
		p.removeUsableWhiteTokens(cost)

		// Mark tech card, no duplicate
		if school.hasType(CARDTYPE_TECH) {
			p.techTokenManager.processRequest(&AddTokenRequest{
				bankId:     school.schoolId,
				tokenType:  TOKEN_DEFAULT,
				tokenCount: 1,
			})
		}

		// Mark leader
		if school.hasType(CARDTYPE_LEADER) {
			p.specialTokenManager.processRequest(&AddTokenRequest{
				bankId:     LEADER_A_TAKEN + school.age,
				tokenType:  TOKEN_DEFAULT,
				tokenCount: 1,
			})
		}

		// Mark action card
		if school.hasType(CARDTYPE_ACTION) {
			p.game.cardTokenManager.processRequest(&SetTokenRequest{
				bankId:     card.id,
				tokenType:  TOKEN_ACTION_CARD_THIS_TURN,
				tokenCount: 1,
			})
		}

		// Aristotle
		if p.specialAbilityAvailable(TRAIT_ARISTOTLE) {
			if school.hasType(CARDTYPE_TECH) {
				p.gainTech(1)
			}
		}
	}
}

func (p *PlayerBoard) getResourceTotal() (result int) {
	csm := p.game.cardStackManager
	result = 0
	for _, card := range csm.cardStacks[p.stacks[MINE]] {
		school := p.game.cardSchools[card.schoolId]
		amount := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
		result += school.productionResource * amount
	}
	return
}

func (p *PlayerBoard) getCropTotal() (result int) {
	csm := p.game.cardStackManager
	result = 0
	for _, card := range csm.cardStacks[p.stacks[FARM]] {
		school := p.game.cardSchools[card.schoolId]
		amount := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
		result += school.productionCrop * amount
	}
	return
}

// Calculate the "best" solution to spent an amount of resource/crop
func (p *PlayerBoard) tryArrangeSpend(q, unit []int, free, spent int) (possible bool, arranged []int) {
	for i, _ := range q {
		for {
			if q[i] > 0 && unit[i] <= spent {
				q[i]--
				free++
				spent -= unit[i]
			} else {
				break
			}
		}

		if spent == 0 {
			return true, q
		}

		if q[i] > 0 && unit[i] > spent {
			q[i]--
			free++
			spent -= unit[i] // Spent will be < 0
			for {
				i--
				for {
					if unit[i]+spent <= 0 {
						if free > 0 {
							free--
						} else {
							return true, q
						}
						q[i] += 1
						spent += unit[i]
					} else {
						break
					}
				}

				if spent == 0 {
					return true, q
				}
			}
		}
	}

	return false, nil
}

func (p *PlayerBoard) gainTempMilitaryResource(amount int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     MILITARY_RESOURCE_TEMP,
		tokenType:  TOKEN_BLUE,
		tokenCount: amount,
	})
}

func (p *PlayerBoard) gainTempMilitaryResourceForBuildArmy(amount int) {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     MILITARY_RESOURCE_TEMP_BUILD_ONLY,
		tokenType:  TOKEN_BLUE,
		tokenCount: amount,
	})
}

func (p *PlayerBoard) clearTempMilitaryResource() {
	p.specialTokenManager.processRequest(&SetTokenRequest{
		bankId:     MILITARY_RESOURCE_TEMP,
		tokenType:  TOKEN_BLUE,
		tokenCount: 0,
	})
}

func (p *PlayerBoard) spendTempMilitaryResource(amount int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     MILITARY_RESOURCE_TEMP,
		tokenType:  TOKEN_BLUE,
		tokenCount: amount,
	})
}

func (p *PlayerBoard) spendTempMilitaryResourceForBuildArmy(amount int) {
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     MILITARY_RESOURCE_TEMP_BUILD_ONLY,
		tokenType:  TOKEN_BLUE,
		tokenCount: amount,
	})
}

func (p *PlayerBoard) spendResourceForUpgradeArmy(amount int) {
	a := p.getTempMilitaryResource()
	if a >= amount {
		p.spendTempMilitaryResource(amount)
	} else {
		amount -= a
	}
	p.spendResource(amount)
}

func (p *PlayerBoard) spendResourceForBuildArmy(amount int) {
	a := p.getTempMilitaryResourceForBuildArmy()
	if a >= amount {
		p.spendTempMilitaryResourceForBuildArmy(a)
	} else {
		amount -= a
	}
	b := p.getTempMilitaryResource()
	if b >= amount {
		p.spendTempMilitaryResource(b)
	} else {
		amount -= b
	}
	p.spendResource(amount)
}

func (p *PlayerBoard) spendResource(amount int) {
	csm := p.game.cardStackManager
	quantity := make([]int, csm.getStackSize(p.stacks[MINE]))
	unit := make([]int, csm.getStackSize(p.stacks[MINE]))

	for i, card := range csm.cardStacks[p.stacks[MINE]] {
		school := p.game.cardSchools[card.schoolId]
		q := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
		quantity[i] = q
		unit[i] = school.productionResource
	}
	sum := 0
	for _, q := range quantity {
		sum += q
	}

	possible, newQuantity := p.tryArrangeSpend(quantity, unit, p.getFreeBlueTokens(), amount)
	if !possible {
		return
	}
	newSum := 0
	for _, q := range newQuantity {
		newSum += q
	}

	for i, card := range csm.cardStacks[p.stacks[MINE]] {
		p.game.cardTokenManager.processRequest(&SetTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: newQuantity[i],
		})
	}
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     FREE_BLUE,
		tokenType:  TOKEN_BLUE,
		tokenCount: sum - newSum,
	})
	return
}

func (p *PlayerBoard) spendAllResource() {
	p.spendResource(p.getResourceTotal())
}

func (p *PlayerBoard) spendCrop(amount int) {
	csm := p.game.cardStackManager
	quantity := make([]int, csm.getStackSize(p.stacks[FARM]))
	unit := make([]int, csm.getStackSize(p.stacks[FARM]))

	for i, card := range csm.cardStacks[p.stacks[FARM]] {
		school := p.game.cardSchools[card.schoolId]
		q := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
		quantity[i] = q
		unit[i] = school.productionCrop
	}
	sum := 0
	for _, q := range quantity {
		sum += q
	}

	possible, newQuantity := p.tryArrangeSpend(quantity, unit, p.getFreeBlueTokens(), amount)
	if !possible {
		return
	}
	newSum := 0
	for _, q := range newQuantity {
		newSum += q
	}

	for i, card := range csm.cardStacks[p.stacks[FARM]] {
		p.game.cardTokenManager.processRequest(&SetTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: newQuantity[i],
		})
	}
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     FREE_BLUE,
		tokenType:  TOKEN_BLUE,
		tokenCount: sum - newSum,
	})
	return
}

func (p *PlayerBoard) spendAllCrop() {
	p.spendCrop(p.getCropTotal())
}

func (p *PlayerBoard) consumeCrop() {
	c := p.getCropConsume()
	crop := p.getCropTotal()
	if c < crop {
		p.spendCrop(c)
	} else {
		p.spendAllCrop()
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     CULTURE_COUNTER,
			tokenType:  TOKEN_DEFAULT,
			tokenCount: 4 * (c - crop),
		})
	}
}

func (p *PlayerBoard) corrupt() {
	c := p.getResourceCorruption()
	//fmt.Println(p.getFreeBlueTokens(), c)

	res := p.getResourceTotal()
	if c <= res {
		p.spendResource(c)
	} else {
		c -= res
		p.spendAllResource()
		crop := p.getCropTotal()
		if c < crop {
			p.spendCrop(c)
		} else {
			p.spendAllCrop()
		}
	}
}

func (p *PlayerBoard) gainCrop(amount int) {
	csm := p.game.cardStackManager
	// Need reverse iterate
	for i := csm.getStackSize(p.stacks[FARM]) - 1; i >= 0; i-- {
		card := csm.cardStacks[p.stacks[FARM]][i]
		school := p.game.cardSchools[card.schoolId]
		unit := school.productionCrop
		for {
			if amount == 0 {
				return
			}
			if amount < unit {
				break
			}
			if p.getFreeBlueTokens() <= 0 {
				return
			}
			p.specialTokenManager.processRequest(&RemoveTokenRequest{
				bankId:     FREE_BLUE,
				tokenType:  TOKEN_BLUE,
				tokenCount: 1,
			})
			p.game.cardTokenManager.processRequest(&AddTokenRequest{
				bankId:     card.id,
				tokenType:  TOKEN_BLUE,
				tokenCount: 1,
			})
			amount -= unit
		}
	}
}

func (p *PlayerBoard) produceCrop() {
	csm := p.game.cardStackManager
	// Need reverse iterate
	for i := csm.getStackSize(p.stacks[FARM]) - 1; i >= 0; i-- {
		card := csm.cardStacks[p.stacks[FARM]][i]
		amount := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_YELLOW)
		if amount > p.getFreeBlueTokens() {
			amount = p.getFreeBlueTokens()
		}
		if amount == 0 {
			return
		}
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     FREE_BLUE,
			tokenType:  TOKEN_BLUE,
			tokenCount: amount,
		})
		p.game.cardTokenManager.processRequest(&AddTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: amount,
		})
	}
}

func (p *PlayerBoard) gainResource(amount int) {
	csm := p.game.cardStackManager
	// Need reverse iterate
	for i := csm.getStackSize(p.stacks[MINE]) - 1; i >= 0; i-- {
		card := csm.cardStacks[p.stacks[MINE]][i]
		school := p.game.cardSchools[card.schoolId]
		unit := school.productionResource
		for {
			if amount == 0 {
				return
			}
			if amount < unit {
				break
			}
			if p.getFreeBlueTokens() <= 0 {
				return
			}
			p.specialTokenManager.processRequest(&RemoveTokenRequest{
				bankId:     FREE_BLUE,
				tokenType:  TOKEN_BLUE,
				tokenCount: 1,
			})
			p.game.cardTokenManager.processRequest(&AddTokenRequest{
				bankId:     card.id,
				tokenType:  TOKEN_BLUE,
				tokenCount: 1,
			})
			amount -= unit
		}
	}
}

func (p *PlayerBoard) produceResource() {
	csm := p.game.cardStackManager
	// Need reverse iterate
	bestMine := true
	for i := csm.getStackSize(p.stacks[MINE]) - 1; i >= 0; i-- {
		card := csm.cardStacks[p.stacks[MINE]][i]
		amount := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_YELLOW)

		if p.specialAbilityAvailable(TRAIT_TRANSCONT_RR) && bestMine {
			amount += 1
		}
		if amount > p.getFreeBlueTokens() {
			amount = p.getFreeBlueTokens()
		}

		if amount == 0 {
			return
		}
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     FREE_BLUE,
			tokenType:  TOKEN_BLUE,
			tokenCount: amount,
		})
		p.game.cardTokenManager.processRequest(&AddTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: amount,
		})
		bestMine = false
	}
}

func (p *PlayerBoard) productCultureAndTech() {
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     CULTURE_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: p.calcCultureInc(),
	})
	p.specialTokenManager.processRequest(&AddTokenRequest{
		bankId:     TECH_COUNTER,
		tokenType:  TOKEN_DEFAULT,
		tokenCount: p.calcTechInc(),
	})
}

func (p *PlayerBoard) doProductionPhase() {
	p.productCultureAndTech()
	p.corrupt()
	p.produceCrop()
	p.consumeCrop()
	p.produceResource()
}

func attachmentAsInt(attachment interface{}, def int) int {
	if attachment == nil {
		return def
	}
	switch attachment := attachment.(type) {
	case int:
		return attachment
	case []int:
		if len(attachment) <= 0 {
			return def
		} else {
			return attachment[0]
		}
	default:
		return def
	}
}

func attachmentAsIntList(attachment interface{}, def []int) []int {
	if attachment == nil {
		return def
	}
	switch attachment := attachment.(type) {
	case []int:
		return attachment
	default:
		return def
	}
}

func (p *PlayerBoard) canPlayBreakthrough(card Card, index int) bool {
	csm := p.game.cardStackManager
	if index < 0 || index >= p.getCivilHandSize() {
		return false
	}
	nestedCard := csm.cardStacks[p.stacks[HAND]][index]
	school := p.game.cardSchools[nestedCard.schoolId]
	if !school.hasType(CARDTYPE_TECH) {
		return false
	}

	return p.canPlayCard(nestedCard, nil)
}

func (p *PlayerBoard) canPlayEfficientUpgrade(card Card, stacksAndIndexes []int) bool {
	school := p.game.cardSchools[card.schoolId]
	if len(stacksAndIndexes) != 3 {
		return false
	}
	return p.canUpgrade(stacksAndIndexes[0],
		stacksAndIndexes[1], stacksAndIndexes[2], school.actionBonus)
}

func (p *PlayerBoard) canPlayEngineeringGenius(card Card) bool {
	school := p.game.cardSchools[card.schoolId]
	return p.canBuildWonder(1, school.actionBonus)
}

func (p *PlayerBoard) canPlayFrugality(card Card) bool {
	return p.canIncreasePop()
}

func (p *PlayerBoard) canPlayRichLand(card Card, stacksAndIndexes []int) bool {
	school := p.game.cardSchools[card.schoolId]
	if len(stacksAndIndexes) == 2 { // Used to build
		stack := stacksAndIndexes[0]
		index := stacksAndIndexes[1]

		if stack == FARM ||
			stack == MINE {
			return p.canBuild(stack, index, school.actionBonus)
		} else {
			return false
		}
	} else if len(stacksAndIndexes) == 3 { // Used to upgrade
		stack := stacksAndIndexes[0]
		index1 := stacksAndIndexes[1]
		index2 := stacksAndIndexes[2]

		if stack == FARM ||
			stack == MINE {
			return p.canUpgrade(stack, index1, index2, school.actionBonus)
		} else {
			return false
		}
	} else {
		return false
	}

}

func (p *PlayerBoard) canPlayUrbanGrowth(card Card, stacksAndIndexes []int) bool {
	school := p.game.cardSchools[card.schoolId]
	if len(stacksAndIndexes) == 2 { // Used to build
		stack := stacksAndIndexes[0]
		index := stacksAndIndexes[1]
		if stack == URBAN_LAB ||
			stack == URBAN_TEMPLE ||
			stack == URBAN_ARENA ||
			stack == URBAN_LIBRARY ||
			stack == URBAN_THEATER {
			return p.canBuild(stack, index, school.actionBonus)
		} else {
			return false
		}
	} else if len(stacksAndIndexes) == 3 { // Used to upgrade
		stack := stacksAndIndexes[0]
		index1 := stacksAndIndexes[1]
		index2 := stacksAndIndexes[2]
		if stack == URBAN_LAB ||
			stack == URBAN_TEMPLE ||
			stack == URBAN_ARENA ||
			stack == URBAN_LIBRARY ||
			stack == URBAN_THEATER {
			return p.canUpgrade(stack, index1, index2, school.actionBonus)
		} else {
			return false
		}
	} else {
		return false
	}
}

func (p *PlayerBoard) canPlayCard(card Card, attachment interface{}) bool {
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_TECH) {
		// TODO tech cost reduction effects here
		if school.hasType(CARDTYPE_TECH_GOVERNMENT) {
			att := attachmentAsInt(attachment, 0)
			if att == 0 {
				return p.getUsableWhiteTokens() >= 1 && p.getTechTotal() >= school.tech
			} else {
				// TODO Robespierre here
				return p.getUsableWhiteTokens() >= p.calcWhiteTokenLimit() &&
					p.getTechTotal() >= school.techRevolution
			}
		}
		if p.getUsableWhiteTokens() < 1 {
			return false
		}

		if school.hasType(CARDTYPE_TECH_MILI) {
			return p.getTechTotal()+p.getTechForMilitary() >= school.tech
		} else {
			return p.getTechTotal() >= school.tech
		}
	} else if school.hasType(CARDTYPE_ACTION) {
		if p.getUsableWhiteTokens() >= 1 {
			if p.game.cardTokenManager.getTokenCount(card.id, TOKEN_ACTION_CARD_THIS_TURN) > 0 {
				return false
			}
			if school.hasType(CARDTYPE_ACTION_BREAKTHROUGH) {
				return p.canPlayBreakthrough(card, attachmentAsInt(attachment, -1))
			} else if school.hasType(CARDTYPE_ACTION_CULTURAL_HERITAGE) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_EFFICIENT_UPGRADE) {
				return p.canPlayEfficientUpgrade(card, attachmentAsIntList(attachment, []int{}))
			} else if school.hasType(CARDTYPE_ACTION_ENDOWMENT_FOR_ARTS) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_ENGINEERING_GENIUS) {
				return p.canPlayEngineeringGenius(card)
			} else if school.hasType(CARDTYPE_ACTION_FRUGALITY) {
				return p.canPlayFrugality(card)
			} else if school.hasType(CARDTYPE_ACTION_MILITARY_BUILD_UP) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_PATRIOTISM) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_RESERVES) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_REVOLUTIONARY_IDEA) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_RICH_LAND) {
				return p.canPlayRichLand(card, attachmentAsIntList(attachment, []int{}))
			} else if school.hasType(CARDTYPE_ACTION_STOCKPILE) {
				return true
			} else if school.hasType(CARDTYPE_ACTION_URBAN_GROWTH) {
				return p.canPlayUrbanGrowth(card, attachmentAsIntList(attachment, []int{}))
			} else if school.hasType(CARDTYPE_ACTION_WAVE_OF_NATIONALISM) {
				return true
			}
		}
		return false
	} else if school.hasType(CARDTYPE_LEADER) {
		return p.getUsableWhiteTokens() >= 1
	}
	return false
}

func (p *PlayerBoard) canPlayHand(index int, attachment interface{}) bool {
	csm := p.game.cardStackManager
	if index < 0 || index >= p.getCivilHandSize() {
		return false
	}

	card := csm.cardStacks[p.stacks[HAND]][index]
	return p.canPlayCard(card, attachment)
}

func (p *PlayerBoard) playStructureTechCard(card Card, index int, stackId int) {
	csm := p.game.cardStackManager
	school := p.game.cardSchools[card.schoolId]
	stack := csm.cardStacks[p.stacks[stackId]]
	i := 0
	for {
		if i >= len(stack) {
			break
		}

		cardAti := stack[i]
		schoolAti := p.game.cardSchools[cardAti.schoolId]
		if schoolAti.age >= school.age {
			break
		}
		i += 1
	}

	if school.hasType(CARDTYPE_TECH_MILI) {
		p.payTechForMilitary(school.tech)
	} else {
		p.payTech(school.tech)
	}
	p.removeUsableWhiteTokens(1)
	csm.processRequest(&MoveCardRequest{
		sourcePosition: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
		targetPosition: CardPosition{
			stackId:  p.stacks[stackId],
			position: i,
		},
	})
}

func (p *PlayerBoard) playSpecialTechCard(card Card, index int, stackId int) {
	csm := p.game.cardStackManager
	school := p.game.cardSchools[card.schoolId]

	p.payTech(school.tech)
	p.removeUsableWhiteTokens(1)
	if csm.getStackSize(p.stacks[stackId]) > 0 {
		csm.processRequest(&BanishCardRequest{
			position: CardPosition{
				stackId:  p.stacks[stackId],
				position: 0,
			},
		})
	}
	csm.processRequest(&MoveCardRequest{
		sourcePosition: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
		targetPosition: CardPosition{
			stackId:  p.stacks[stackId],
			position: 0,
		},
	})
	p.realignWhiteRedTokens()
}

func (p *PlayerBoard) playBreakthroughCard(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	school := p.game.cardSchools[card.schoolId]

	nestedIndex := attachmentAsInt(attachment, -1)
	nestedCard := csm.cardStacks[p.stacks[HAND]][nestedIndex]

	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	if index > nestedIndex {
		p.playCard(nestedCard, nestedIndex, nil)
	} else {
		p.playCard(nestedCard, nestedIndex+1, nil)
	}
	p.gainTech(school.actionBonus)
}

func (p *PlayerBoard) playCulturalHeritageCard(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})
	school := p.game.cardSchools[card.schoolId]

	p.removeUsableWhiteTokens(1)
	if school.age == 0 {
		p.gainTech(1)
		p.gainCulture(4)
	} else if school.age == 1 {
		p.gainTech(2)
		p.gainCulture(2)
	}
}

func (p *PlayerBoard) playEfficientUpgradeCard(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	stacksAndIndexes := attachmentAsIntList(attachment, []int{})
	school := p.game.cardSchools[card.schoolId]
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})
	p.upgrade(stacksAndIndexes[0],
		stacksAndIndexes[1], stacksAndIndexes[2], school.actionBonus)
}

func (p *PlayerBoard) playEndowmentForArtsCard(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	p.removeUsableWhiteTokens(1)
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	// TODO Endowment for arts
}

func (p *PlayerBoard) playEngineeringGenius(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})
	school := p.game.cardSchools[card.schoolId]
	p.buildWonder(1, school.actionBonus)
}

func (p *PlayerBoard) playFrugality(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})
	p.increasePop()

	school := p.game.cardSchools[card.schoolId]
	p.gainCrop(school.actionBonus)
}

func (p *PlayerBoard) playMilitaryBuildUp(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	n := p.game.countPlayersWithPowerMoreThan(p.calcPower())
	switch p.game.options.PlayerCount {
	case 2:
		p.gainTempMilitaryResourceForBuildArmy(n * 8)
	case 3:
		p.gainTempMilitaryResourceForBuildArmy(n * 5)
	case 4:
		p.gainTempMilitaryResourceForBuildArmy(n * 3)
	}
}

func (p *PlayerBoard) playPatroitism(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	school := p.game.cardSchools[card.schoolId]
	p.gainTempMilitaryResourceForBuildArmy(school.actionBonus)
	p.gainTempRedTokens(1)
}

func (p *PlayerBoard) playReserves(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	school := p.game.cardSchools[card.schoolId]
	option := attachmentAsInt(attachment, 0)
	if option == 0 {
		p.gainResource(school.actionBonus)
	} else {
		p.gainCrop(school.actionBonus)
	}
}

func (p *PlayerBoard) playRevolutionaryIdea(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	school := p.game.cardSchools[card.schoolId]
	p.gainTech(school.actionBonus)
}

func (p *PlayerBoard) playRichLandOrUrbanGrowth(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})
	stacksAndIndexes := attachmentAsIntList(attachment, []int{})
	school := p.game.cardSchools[card.schoolId]
	if len(stacksAndIndexes) == 2 { // Build
		stack := stacksAndIndexes[0]
		index := stacksAndIndexes[1]
		p.build(stack, index, school.actionBonus)
	} else if len(stacksAndIndexes) == 3 { // Upgrade
		stack := stacksAndIndexes[0]
		index1 := stacksAndIndexes[1]
		index2 := stacksAndIndexes[2]
		p.upgrade(stack, index1, index2, school.actionBonus)
	}
}

func (p *PlayerBoard) playRichLand(card Card, index int, attachment interface{}) {
	p.playRichLandOrUrbanGrowth(card, index, attachment)
}

func (p *PlayerBoard) playStockpile(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	p.gainResource(1)
	p.gainCrop(1)
}

func (p *PlayerBoard) playUrbanGrowth(card Card, index int, attachment interface{}) {
	p.playRichLandOrUrbanGrowth(card, index, attachment)
}

func (p *PlayerBoard) playWaveOfNationalism(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	csm.processRequest(&BanishCardRequest{
		position: CardPosition{
			stackId:  p.stacks[HAND],
			position: index,
		},
	})

	n := p.game.countPlayersWithPowerMoreThan(p.calcPower())
	switch p.game.options.PlayerCount {
	case 2:
		p.gainTempMilitaryResourceForBuildArmy(n * 6)
	case 3:
		p.gainTempMilitaryResourceForBuildArmy(n * 3)
	case 4:
		p.gainTempMilitaryResourceForBuildArmy(n * 2)
	}
}

func (p *PlayerBoard) playCard(card Card, index int, attachment interface{}) {
	csm := p.game.cardStackManager
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_TECH) {
		// TODO: all tech cost modifiers
		if school.hasType(CARDTYPE_TECH_FARM) {
			p.playStructureTechCard(card, index, FARM)
		} else if school.hasType(CARDTYPE_TECH_MINE) {
			p.playStructureTechCard(card, index, MINE)
		} else if school.hasType(CARDTYPE_TECH_MILI_INFANTRY) {
			p.playStructureTechCard(card, index, MILI_INFANTRY)
		} else if school.hasType(CARDTYPE_TECH_MILI_CAVALRY) {
			p.playStructureTechCard(card, index, MILI_CAVALRY)
		} else if school.hasType(CARDTYPE_TECH_MILI_ARTILLERY) {
			p.playStructureTechCard(card, index, MILI_ARTILERY)
		} else if school.hasType(CARDTYPE_TECH_MILI_AIRFORCE) {
			p.playStructureTechCard(card, index, MILI_AIRFORCE)
		} else if school.hasType(CARDTYPE_TECH_URBAN_TEMPLE) {
			p.playStructureTechCard(card, index, URBAN_TEMPLE)
		} else if school.hasType(CARDTYPE_TECH_URBAN_LAB) {
			p.playStructureTechCard(card, index, URBAN_LAB)
		} else if school.hasType(CARDTYPE_TECH_URBAN_ARENA) {
			p.playStructureTechCard(card, index, URBAN_ARENA)
		} else if school.hasType(CARDTYPE_TECH_URBAN_LIBRARY) {
			p.playStructureTechCard(card, index, URBAN_LIBRARY)
		} else if school.hasType(CARDTYPE_TECH_URBAN_THEATER) {
			p.playStructureTechCard(card, index, URBAN_THEATER)
		} else if school.hasType(CARDTYPE_TECH_SPECIAL_MILITARY) {
			p.playSpecialTechCard(card, index, TECH_SPECIAL_WARFARE)
		} else if school.hasType(CARDTYPE_TECH_SPECIAL_CIVIL) {
			p.playSpecialTechCard(card, index, TECH_SPECIAL_CIVIL)
		} else if school.hasType(CARDTYPE_TECH_SPECIAL_COLONIZE) {
			p.playSpecialTechCard(card, index, TECH_SPECIAL_COLONIZE)
		} else if school.hasType(CARDTYPE_TECH_SPECIAL_CONSTRUCTION) {
			p.playSpecialTechCard(card, index, TECH_SPECIAL_CONSTRUCTION)
		} else if school.hasType(CARDTYPE_TECH_GOVERNMENT) {
			att := attachmentAsInt(attachment, 0)
			if att == 0 {
				p.payTech(school.tech)
				p.removeUsableWhiteTokens(1)
			} else {
				// TODO Robespierre here
				p.payTech(school.techRevolution)
				p.removeAllUsableWhiteTokens()
			}

			fmt.Println("Changing government")
			csm.processRequest(&BanishCardRequest{
				position: CardPosition{
					stackId:  p.stacks[GOVERNMENT],
					position: 0,
				},
			})
			csm.processRequest(&MoveCardRequest{
				sourcePosition: CardPosition{
					stackId:  p.stacks[HAND],
					position: index,
				},
				targetPosition: CardPosition{
					stackId:  p.stacks[GOVERNMENT],
					position: 0,
				},
			})
			p.realignWhiteRedTokens()
		}

		if p.specialAbilityAvailable(TRAIT_LEONARDO_DA_VINCI) {
			p.gainResource(1)
		} else if p.specialAbilityAvailable(TRAIT_ISAAC_NEWTON) {
			p.removeUsableWhiteTokens(-1)
		} else if p.specialAbilityAvailable(TRAIT_ALBERT_EINSTEIN) {
			p.gainCulture(3)
		}
	} else if school.hasType(CARDTYPE_ACTION) {
		if school.hasType(CARDTYPE_ACTION_BREAKTHROUGH) {
			p.playBreakthroughCard(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_CULTURAL_HERITAGE) {
			p.playCulturalHeritageCard(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_EFFICIENT_UPGRADE) {
			p.playEfficientUpgradeCard(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_ENDOWMENT_FOR_ARTS) {
			p.playEndowmentForArtsCard(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_ENGINEERING_GENIUS) {
			p.playEngineeringGenius(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_FRUGALITY) {
			p.playFrugality(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_MILITARY_BUILD_UP) {
			p.playMilitaryBuildUp(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_PATRIOTISM) {
			p.playPatroitism(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_RESERVES) {
			p.playReserves(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_REVOLUTIONARY_IDEA) {
			p.playRevolutionaryIdea(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_RICH_LAND) {
			p.playRichLand(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_STOCKPILE) {
			p.playStockpile(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_URBAN_GROWTH) {
			p.playUrbanGrowth(card, index, attachment)
		} else if school.hasType(CARDTYPE_ACTION_WAVE_OF_NATIONALISM) {
			p.playWaveOfNationalism(card, index, attachment)
		}
	} else if school.hasType(CARDTYPE_LEADER) {
		if p.hasLeader() {
			// TODO: Homer
			csm.processRequest(&BanishCardRequest{
				position: CardPosition{
					stackId:  p.stacks[LEADER],
					position: 0,
				},
			})
		} else {
			p.removeUsableWhiteTokens(1)
		}

		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[HAND],
				position: index,
			},
			targetPosition: CardPosition{
				stackId:  p.stacks[LEADER],
				position: 0,
			},
		})
		p.realignWhiteRedTokens()
	}
}

func (p *PlayerBoard) playHand(index int, attachment interface{}) {
	csm := p.game.cardStackManager
	card := csm.cardStacks[p.stacks[HAND]][index]
	p.playCard(card, index, attachment)
}

func (p *PlayerBoard) canIncreasePop() bool {
	if p.getUsableWhiteTokens() < 1 {
		fmt.Println("Increase pop no white token")
		return false
	}
	if p.getFreeYellowTokens() <= 0 {
		fmt.Println("Increase pop no free yellow token")
		return false
	}
	cropCost := p.getIncreasePopBaseCost()

	if p.specialAbilityAvailable(TRAIT_MOSES) {
		cropCost -= 1
	}
	if p.getCropTotal() < cropCost {
		fmt.Println("Increase pop not enough crop")
		return false
	}
	return true
}

func (p *PlayerBoard) increasePop() {
	p.removeUsableWhiteTokens(1)
	cropCost := p.getIncreasePopBaseCost()
	if p.specialAbilityAvailable(TRAIT_MOSES) {
		cropCost -= 1
	}
	fmt.Println("increasePop ", cropCost)
	p.spendCrop(cropCost)
	p.specialTokenManager.processRequest(&MoveTokenRequest{
		sourceBankId: FREE_YELLOW,
		targetBankId: FREE_WORKER,
		tokenType:    TOKEN_YELLOW,
		tokenCount:   1,
	})
}

func (p *PlayerBoard) getModifiedCost(card Card) int {
	school := p.game.cardSchools[card.schoolId]
	cost := school.buildCost
	if school.hasType(CARDTYPE_TECH_URBAN) {
		constructionLevel := p.getConstructionTechLevel()
		age := school.age
		if constructionLevel > age {
			cost -= age
		} else {
			cost -= constructionLevel
		}
	}

	if cost < 0 {
		cost = 0
	}
	// TODO: all cost reduction
	return cost
}

func (p *PlayerBoard) canBuild(stack int, index int, reducedCost int) bool {
	csm := p.game.cardStackManager

	// Has free worker
	if p.getFreeWorkers() <= 0 {
		fmt.Println("canBuild no free worker")
		return false
	}

	military := false
	// Valid stacks
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		military = true
		if p.getUsableRedTokens() <= 0 {
			fmt.Println("canBuild no red tokens")
			return false
		}
	} else if stack == FARM ||
		stack == MINE ||
		stack == URBAN_TEMPLE ||
		stack == URBAN_LAB ||
		stack == URBAN_ARENA ||
		stack == URBAN_LIBRARY ||
		stack == URBAN_THEATER {
		if p.getUsableWhiteTokens() <= 0 {
			fmt.Println("canBuild no white tokens")
			return false
		}
	} else {
		fmt.Println("canBuild invalid stack")
		return false
	}

	if index < 0 || index >= csm.getStackSize(p.stacks[stack]) {
		fmt.Println("canBuild invalid card index: ", index)
		return false
	}

	// Urban limit
	card := csm.cardStacks[p.stacks[stack]][index]
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_TECH_URBAN) {
		urbanCount := -1
		if school.hasType(CARDTYPE_TECH_URBAN_LAB) {
			urbanCount = p.getUrbanCount(URBAN_LAB)
		} else if school.hasType(CARDTYPE_TECH_URBAN_TEMPLE) {
			urbanCount = p.getUrbanCount(URBAN_TEMPLE)
		} else if school.hasType(CARDTYPE_TECH_URBAN_ARENA) {
			urbanCount = p.getUrbanCount(URBAN_ARENA)
		} else if school.hasType(CARDTYPE_TECH_URBAN_LIBRARY) {
			urbanCount = p.getUrbanCount(URBAN_LIBRARY)
		} else if school.hasType(CARDTYPE_TECH_URBAN_THEATER) {
			urbanCount = p.getUrbanCount(URBAN_THEATER)
		}

		fmt.Println("urbanCount = ", urbanCount)
		if urbanCount < 0 {
			return false
		}

		fmt.Println("urbanLimit = ", p.calcUrbanLimit())
		if urbanCount >= p.calcUrbanLimit() {
			return false
		}
	}
	// Cost enough
	cost := p.getModifiedCost(card) - reducedCost
	if cost < 0 {
		cost = 0
	}

	if military {
		if p.getResourceTotal()+p.getTempMilitaryResource()+
			p.getTempMilitaryResourceForBuildArmy() < cost {
			fmt.Println("canBuild not enough resource")
			return false
		}
	} else {
		if p.getResourceTotal() < cost {
			fmt.Println("canBuild not enough resource")
			return false
		}
	}
	return true
}

func (p *PlayerBoard) build(stack int, index int, reducedCost int) {
	csm := p.game.cardStackManager
	card := csm.cardStacks[p.stacks[stack]][index]
	cost := p.getModifiedCost(card) - reducedCost
	if cost < 0 {
		cost = 0
	}

	military := false
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		military = true
		p.removeUsableRedTokens(1)
	} else {
		p.removeUsableWhiteTokens(1)
	}
	if military {
		p.spendResourceForBuildArmy(cost)
	} else {
		p.spendResource(cost)
	}
	p.specialTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     FREE_WORKER,
		tokenType:  TOKEN_YELLOW,
		tokenCount: 1,
	})
	p.game.cardTokenManager.processRequest(&AddTokenRequest{
		bankId:     card.id,
		tokenType:  TOKEN_YELLOW,
		tokenCount: 1,
	})
}

func (p *PlayerBoard) canUpgrade(stack, index1, index2, reducedCost int) bool {
	csm := p.game.cardStackManager

	// Valid indexes
	if index1 >= index2 {
		fmt.Println("canUpgrade invalid upgrade")
		return false
	}
	military := false
	// Valid stacks
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		military = true
		if p.getUsableRedTokens() <= 0 {
			fmt.Println("canUpgrade no red tokens")
			return false
		}
	} else if stack == FARM ||
		stack == MINE ||
		stack == URBAN_TEMPLE ||
		stack == URBAN_LAB ||
		stack == URBAN_ARENA ||
		stack == URBAN_LIBRARY ||
		stack == URBAN_THEATER {
		if p.getUsableWhiteTokens() <= 0 {
			fmt.Println("canUpgrade no white tokens")
			return false
		}
	} else {
		fmt.Println("canUpgrade invalid stack")
		return false
	}

	if index1 < 0 || index1 >= csm.getStackSize(p.stacks[stack]) ||
		index2 < 0 || index2 >= csm.getStackSize(p.stacks[stack]) {
		fmt.Println("canUpgrade invalid card index")
		return false
	}

	// Cost enough
	card1 := csm.cardStacks[p.stacks[stack]][index1]
	card2 := csm.cardStacks[p.stacks[stack]][index2]
	cost1 := p.getModifiedCost(card1)
	cost2 := p.getModifiedCost(card2)
	cost := cost2 - cost1 - reducedCost
	if cost < 0 {
		cost = 0
	}

	if military {
		if p.getResourceTotal()+p.getTempMilitaryResource() < cost {
			fmt.Println("canBuild not enough tech")
			return false
		}
	} else {
		if p.getResourceTotal() < cost {
			fmt.Println("canBuild not enough tech")
			return false
		}
	}
	return true
}

func (p *PlayerBoard) upgrade(stack, index1, index2, reducedCost int) {
	csm := p.game.cardStackManager
	card1 := csm.cardStacks[p.stacks[stack]][index1]
	card2 := csm.cardStacks[p.stacks[stack]][index2]
	cost := p.getModifiedCost(card2) - p.getModifiedCost(card1) - reducedCost
	if cost < 0 {
		cost = 0
	}

	military := false
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		military = true
		p.removeUsableRedTokens(1)
	} else {
		p.removeUsableWhiteTokens(1)
	}
	if military {
		p.spendResourceForUpgradeArmy(cost)
	} else {
		p.spendResource(cost)
	}
	p.game.cardTokenManager.processRequest(&MoveTokenRequest{
		sourceBankId: card1.id,
		targetBankId: card2.id,
		tokenType:    TOKEN_YELLOW,
		tokenCount:   1,
	})
}

func (p *PlayerBoard) canBuildWonder(step, reducedCost int) bool {
	csm := p.game.cardStackManager
	if p.getUsableWhiteTokens() < 1 {
		return false
	}
	if step <= 0 || step > p.getConstructionTechLevel()+1 {
		return false
	}
	if !p.isBuildingWonder() {
		return false
	}

	card := csm.getFirstCard(p.stacks[WONDER_NOT_COMPLETED])
	school := p.game.cardSchools[card.schoolId]
	stepsBuilt := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
	allSteps := school.wonderBuildCosts
	if step+stepsBuilt > len(allSteps) {
		return false
	}

	cost := 0
	for i := 0; i < step; i++ {
		cost += allSteps[stepsBuilt+i]
	}
	cost -= reducedCost
	if cost < 0 {
		cost = 0
	}
	if cost > p.getResourceTotal() {
		fmt.Println("canBuildWonder not enough resource")
		return false
	}

	// Corner case: not enough blue tokens
	if step+stepsBuilt < len(allSteps) &&
		p.getFreeBlueTokens()+p.getBlueTokensOnMine() < step {
		fmt.Println("canBuildWonder not enough blue tokens")
		return false
	}

	return true
}

func (p *PlayerBoard) buildWonder(step, reducedCost int) {
	csm := p.game.cardStackManager
	card := csm.getFirstCard(p.stacks[WONDER_NOT_COMPLETED])
	school := p.game.cardSchools[card.schoolId]
	stepsBuilt := p.game.cardTokenManager.getTokenCount(card.id, TOKEN_BLUE)
	allSteps := school.wonderBuildCosts

	cost := 0
	for i := 0; i < step; i++ {
		cost += allSteps[stepsBuilt+i]
	}
	cost -= reducedCost
	if cost < 0 {
		cost = 0
	}

	p.removeUsableWhiteTokens(1)
	p.spendResource(cost)

	if step+stepsBuilt < len(allSteps) { // Not completed
		p.specialTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     FREE_BLUE,
			tokenType:  TOKEN_BLUE,
			tokenCount: step,
		})
		p.game.cardTokenManager.processRequest(&AddTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: step,
		})
	} else { // completed
		blues := p.getBlueTokensOnCurrentWonder()
		p.specialTokenManager.processRequest(&AddTokenRequest{
			bankId:     FREE_BLUE,
			tokenType:  TOKEN_BLUE,
			tokenCount: blues,
		})
		p.game.cardTokenManager.processRequest(&RemoveTokenRequest{
			bankId:     card.id,
			tokenType:  TOKEN_BLUE,
			tokenCount: blues,
		})
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[WONDER_NOT_COMPLETED],
				position: 0,
			},
			targetPosition: CardPosition{
				stackId:  p.stacks[WONDER_COMPLETED],
				position: csm.getStackSize(p.stacks[WONDER_COMPLETED]),
			},
		})
		p.realignWhiteRedTokens()
		// Age III wonders
		if school.hasTrait(TRAIT_HOLLYWOOD) {
			p.gainCulture(p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
				if school.hasType(CARDTYPE_TECH_URBAN_LIBRARY) ||
					school.hasType(CARDTYPE_TECH_URBAN_THEATER) {
					return 2 * school.productionCulture
				}
				return 0
			}, false))
		} else if school.hasTrait(TRAIT_INTERNET) {
			p.gainCulture(p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
				if school.hasType(CARDTYPE_TECH_URBAN) {
					return school.productionCulture + school.productionTech +
						school.productionPower
				}
				return 0
			}, false))
		} else if school.hasTrait(TRAIT_FIRST_SPACE_FLIGHT) {
			p.gainCulture(p.iterateOverTechs(func(school *CardSchool) int {
				if school.hasType(CARDTYPE_TECH_URBAN) {
					return school.age
				}
				return 0
			}, false))
		} else if school.hasTrait(TRAIT_FAST_FOOD_CHAINS) {
			p.gainCulture(p.sumOverUnitsAndEverything(func(school *CardSchool) interface{} {
				if school.hasType(CARDTYPE_TECH_MILI) ||
					school.hasType(CARDTYPE_TECH_URBAN) {
					return 1
				} else if school.hasType(CARDTYPE_TECH_FARM) ||
					school.hasType(CARDTYPE_TECH_MINE) {
					return 2
				}
				return 0
			}, false))
		}
	}
}

func (p *PlayerBoard) canUseCivilSpecialAbility(sa int, attachment interface{}) bool {
	switch sa {
	case TRAIT_OCEAN_LINER_SERVICE:
		return p.getFreeYellowTokens() > 0 &&
			!p.perTurnSpecialAbilityUsed(TRAIT_OCEAN_LINER_SERVICE)
	case TRAIT_HAMMURABI:
		return p.getUsableRedTokens() >= 1 &&
			!p.perTurnSpecialAbilityUsed(TRAIT_HAMMURABI)
	case TRAIT_HOMER:
		return !p.perTurnSpecialAbilityUsed(TRAIT_HOMER)
	case TRAIT_WINSTON_CHURCHILL:
		return !p.perTurnSpecialAbilityUsed(TRAIT_WINSTON_CHURCHILL)
	}
	return false
}

func (p *PlayerBoard) useCivilSpecialAbility(sa int, attachment interface{}) {
	switch sa {
	case TRAIT_OCEAN_LINER_SERVICE:
		p.specialTokenManager.processRequest(&MoveTokenRequest{
			sourceBankId: FREE_YELLOW,
			targetBankId: FREE_WORKER,
			tokenType:    TOKEN_YELLOW,
			tokenCount:   1,
		})
		p.markPerTurnSpecialAbility(TRAIT_OCEAN_LINER_SERVICE)
	case TRAIT_HAMMURABI:
		p.removeUsableRedTokens(1)
		p.gainTempWhiteTokens(1)
		p.markPerTurnSpecialAbility(TRAIT_HAMMURABI)
	case TRAIT_HOMER:
		p.gainTempMilitaryResource(1)
		p.markPerTurnSpecialAbility(TRAIT_HOMER)
	case TRAIT_WINSTON_CHURCHILL:
		p.gainTempMilitaryTech(3)
		p.gainTempMilitaryResource(3)
		p.markPerTurnSpecialAbility(TRAIT_WINSTON_CHURCHILL)
	}
}

func (p *PlayerBoard) drawMiliCards(count int) {
	csm := p.game.cardStackManager
	for i := 0; i < count; i++ {
		if csm.getStackSize(p.game.miliDecks[p.game.getCurrentAge()]) == 0 &&
			csm.getStackSize(p.game.miliDiscardDecks[p.game.getCurrentAge()]) > 0 {
			p.game.reshuffleMilitaryDeck()
		}

		if csm.getStackSize(p.game.miliDecks[p.game.getCurrentAge()]) <= 0 {
			return
		}
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.game.miliDecks[p.game.getCurrentAge()],
				position: 0,
			},
			targetPosition: CardPosition{
				stackId:  p.stacks[MILI_HAND],
				position: 0,
			},
		})
	}
}

func (p *PlayerBoard) canDiscardMiliCards(indexes []int) bool {
	dupMap := make(map[int]bool)
	for _, index := range indexes {
		if _, ok := dupMap[index]; ok {
			return false
		} else {
			dupMap[index] = true
		}

		if index < 0 || index >= p.getMilitaryHandSize() {
			return false
		}
	}
	return true
}

func (p *PlayerBoard) discardMiliCards(indexes []int) {
	csm := p.game.cardStackManager
	sort.Sort(sort.Reverse(sort.IntSlice(indexes)))
	for _, index := range indexes {
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[MILI_HAND],
				position: index,
			},
			targetPosition: CardPosition{
				stackId:  p.game.miliDiscardDecks[p.game.getCurrentAge()],
				position: 0,
			},
		})
	}
}

func (p *PlayerBoard) politicalPlayMilitaryHandLegal(index int, attachment interface{}) bool {
	csm := p.game.cardStackManager
	if index < 0 || index >= p.getMilitaryHandSize() {
		return false
	}

	card := csm.cardStacks[p.stacks[MILI_HAND]][index]
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_EVENT) ||
		school.hasType(CARDTYPE_TERRITORY) {
		return true
	} else if school.hasType(CARDTYPE_AGGRESSION) {
		target := attachmentAsInt(attachment, -1)
		if target < 0 || target >= p.game.options.PlayerCount {
			fmt.Println("politicalPlayMilitaryHandLegal invalid player:", target)
			return false
		}
		if target == p.game.CurrentPlayer {
			fmt.Println("politicalPlayMilitaryHandLegal cannot target current player")
			return false
		}

		if p.getUsableRedTokens() < school.miliActionCost {
			fmt.Println("politicalPlayMilitaryHandLegal not enough red tokens")
			return false
		}
		target_power := p.game.players[target].calcPower()
		if target_power >= p.calcPower() {
			return false
		}
		return true
	} else if school.hasType(CARDTYPE_PACT) {
		attachment := attachmentAsIntList(attachment, []int{})
		if len(attachment) < 1 {
			fmt.Println("politicalPlayMilitaryHandLegal not enough parameters")
			return false
		}
		target := attachment[0]
		if target < 0 || target >= p.game.options.PlayerCount {
			fmt.Println("politicalPlayMilitaryHandLegal invalid player:", target)
			return false
		}
		if target == p.game.CurrentPlayer {
			return false
		}
		return true
	}
	return false
}

func (p *PlayerBoard) politicalPlayMilitaryHand(index int, attachment interface{}) {
	csm := p.game.cardStackManager
	card := csm.cardStacks[p.stacks[MILI_HAND]][index]
	school := p.game.cardSchools[card.schoolId]
	if school.hasType(CARDTYPE_EVENT) ||
		school.hasType(CARDTYPE_TERRITORY) {
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[MILI_HAND],
				position: index,
			},
			targetPosition: CardPosition{
				stackId:  p.game.futureEventsDeck,
				position: csm.getStackSize(p.game.futureEventsDeck),
			},
		})
		p.game.nextEventHappen()
	} else if school.hasType(CARDTYPE_AGGRESSION) {
		target := attachmentAsInt(attachment, -1)
		targetPlayer := p.game.players[target]
		p.removeUsableRedTokens(school.miliActionCost)
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[MILI_HAND],
				position: index,
			},
			targetPosition: CardPosition{
				stackId:  targetPlayer.stacks[PENDING],
				position: 0,
			},
		})
	} else if school.hasType(CARDTYPE_PACT) {
		attachment := attachmentAsIntList(attachment, []int{})
		target := attachment[0]
		bSide := false
		if len(attachment) > 1 && attachment[1] > 0 {
			bSide = true
		}
		// Set ab side token
		if bSide {
			p.game.cardTokenManager.processRequest(&AddTokenRequest{
				bankId:     card.id,
				tokenType:  PACT_B,
				tokenCount: 1,
			})
		} else {
			p.game.cardTokenManager.processRequest(&AddTokenRequest{
				bankId:     card.id,
				tokenType:  PACT_A,
				tokenCount: 1,
			})
		}

		targetPlayer := p.game.players[target]
		csm.processRequest(&MoveCardRequest{
			sourcePosition: CardPosition{
				stackId:  p.stacks[MILI_HAND],
				position: index,
			},
			targetPosition: CardPosition{
				stackId:  targetPlayer.stacks[PENDING],
				position: 0,
			},
		})
	}
}

func (p *PlayerBoard) defenseAggressionLegal(indexes []int) bool {
	if len(indexes) > p.calcRedTokenLimit() {
		fmt.Println("defenseAggressionLegal too many cards")
		return false
	}
	dupMap := make(map[int]bool)
	for _, index := range indexes {
		if _, ok := dupMap[index]; ok {
			fmt.Println("defenseAggressionLegal duplicate index")
			return false
		} else {
			dupMap[index] = true
		}

		if index < 0 || index >= p.getMilitaryHandSize() {
			fmt.Println("defenseAggressionLegal invalid index")
			return false
		}
	}
	return true
}

func (p *PlayerBoard) defenseAggressionPowerBonus(indexes []int) int {
	csm := p.game.cardStackManager
	result := 0
	for _, index := range indexes {
		card := csm.cardStacks[p.stacks[MILI_HAND]][index]
		school := p.game.cardSchools[card.schoolId]
		if school.hasType(CARDTYPE_DEFCOL) {
			result += school.age * 2
		} else {
			result += 1
		}
	}
	fmt.Println("DefenseAgreesion discarded ", len(indexes), " cards, ",
		result, " strength gained.")
	return result
}

func (p *PlayerBoard) defenseAggression(indexes []int) {
	p.discardMiliCards(indexes)
}

func (p *PlayerBoard) canDisband(stack, index int) bool {
	// Valid stacks
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE ||
		stack == FARM ||
		stack == MINE ||
		stack == URBAN_TEMPLE ||
		stack == URBAN_LAB ||
		stack == URBAN_ARENA ||
		stack == URBAN_LIBRARY ||
		stack == URBAN_THEATER {
		// Farm, mine, urban buildings or military units
	} else {
		return false
	}

	if p.getWorkerCount(stack, index) <= 0 {
		fmt.Println("canDisband invalid: no unit to disband", stack, index)
		return false
	}

	return true
}

func (p *PlayerBoard) disband(stack, index int, toFreeWorkerPool bool) {
	csm := p.game.cardStackManager
	card := csm.cardStacks[p.stacks[stack]][index]
	p.game.cardTokenManager.processRequest(&RemoveTokenRequest{
		bankId:     card.id,
		tokenType:  TOKEN_YELLOW,
		tokenCount: 1,
	})
	if toFreeWorkerPool {
		p.specialTokenManager.processRequest(&AddTokenRequest{
			bankId:     FREE_WORKER,
			tokenType:  TOKEN_YELLOW,
			tokenCount: 1,
		})
	} else {
		p.specialTokenManager.processRequest(&AddTokenRequest{
			bankId:     FREE_YELLOW,
			tokenType:  TOKEN_YELLOW,
			tokenCount: 1,
		})
	}
}

func (p *PlayerBoard) civilDisbandLegal(stack, index int) bool {
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		if p.getUsableRedTokens() <= 0 {
			return false
		}
	} else {
		if p.getUsableWhiteTokens() <= 0 {
			return false
		}
	}
	return p.canDisband(stack, index)
}

func (p *PlayerBoard) civilDisband(stack, index int) {
	if stack == MILI_INFANTRY ||
		stack == MILI_CAVALRY ||
		stack == MILI_ARTILERY ||
		stack == MILI_AIRFORCE {
		p.removeUsableRedTokens(1)
	} else {
		p.removeUsableWhiteTokens(1)
	}
	p.disband(stack, index, true)
}

func (p *PlayerBoard) civilPlayTacticLegal(index int) bool {
	csm := p.game.cardStackManager
	if index < 0 || index >= csm.getStackSize(p.stacks[MILI_HAND]) {
		fmt.Println("civilPlayTacticLegal invalid index")
		return false
	}
	card := csm.cardStacks[p.stacks[MILI_HAND]][index]
	school := p.game.cardSchools[card.schoolId]

	if p.getUsableRedTokens() <= 0 {
		fmt.Println("civilPlayTacticLegal not enough red tokens")
		return false
	}
	return school.hasType(CARDTYPE_TACTIC)
}

func (p *PlayerBoard) civilPlayTactic(index int) {
	csm := p.game.cardStackManager
	p.removeUsableRedTokens(1)
	p.game.clearTacticUserTokens(p.game.CurrentPlayer)
	if csm.getStackSize(p.stacks[TACTIC]) > 0 {
		csm.processRequest(&BanishCardRequest{
			position: CardPosition{
				stackId:  p.stacks[TACTIC],
				position: 0,
			},
		})
	}

	csm.processRequest(&MoveCardRequest{
		sourcePosition: CardPosition{
			stackId:  p.stacks[MILI_HAND],
			position: index,
		},
		targetPosition: CardPosition{
			stackId:  p.stacks[TACTIC],
			position: 0,
		},
	})
}

func (p *PlayerBoard) civilLearnTacticLegal(index int) bool {
	csm := p.game.cardStackManager
	if index < 0 || index >= csm.getStackSize(p.game.publicTacticDeck) {
		fmt.Println("civilLearnTacticLegal invalid index")
		return false
	}
	if p.getUsableRedTokens() <= 1 {
		fmt.Println("civilLearnTacticLegal not enough red tokens")
		return false
	}
	return true
}

func (p *PlayerBoard) civilLearnTactic(index int) {
	csm := p.game.cardStackManager
	p.removeUsableRedTokens(2)
	g := p.game
	if csm.getStackSize(p.stacks[TACTIC]) > 0 {
		csm.processRequest(&BanishCardRequest{
			position: CardPosition{
				stackId:  p.stacks[TACTIC],
				position: 0,
			},
		})
	}
	g.clearTacticUserTokens(g.CurrentPlayer)
	g.userLearnTactic(p.game.CurrentPlayer, index)
}

func (p *PlayerBoard) politicalBreakPactLegal(pid int) bool {
	g := p.game
	csm := g.cardStackManager
	if pid < 0 || pid >= g.options.PlayerCount {
		fmt.Println("politicalBreakPactLegal invalid index")
		return false
	}

	card := csm.getFirstCard(g.players[pid].stacks[PACT])
	if card == nil {
		fmt.Println("politicalBreakPactLegal pact not found")
		return false
	}

	if pid != p.getIndex() {
		if g.cardTokenManager.getTokenCount(card.id, p.getIndex()) <= 0 {
			fmt.Println("politicalBreakPactLegal not part of the pact")
			return false
		}
	}
	return true
}

func (p *PlayerBoard) politicalBreakPact(pid int) {
	p.game.removePact(pid)
}
